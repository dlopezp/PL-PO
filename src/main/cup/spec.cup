import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;

import symbols.Localizable;

import symbols.Location;
import symbols.SymbolFactory;
import symbols.PLSymbol;
import symbols.TerminalSymbol;

action code{:
    private int errors = 0;

    public int getErrors() {
        return errors;
    }

    public void error(SyntaxError error, Localizable symbol) {
        errors++;
        StringBuilder sb = new StringBuilder();
        sb.append("SyntaxError => ");
        sb.append(error.location(symbol));
        sb.append(": " + error.comment());
        System.out.println(sb.toString());
    }
:}

parser code {:
    public void syntax_error (Symbol currentToken) {
        StringBuilder sb = new StringBuilder();
        sb.append("Syntax Error => ");
        sb.append(", Line: "+currentToken.left);
        sb.append(", Column: "+currentToken.right);
        sb.append(", Value: "+currentToken.value);
        List<Integer> ids = expected_token_ids();
        sb.append("\nExpected: ");
        for (Integer id:ids) {
            sb.append(symbl_name_from_id(id)+", ");
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.deleteCharAt(sb.length() - 1);
        sb.append("\n");
        report_error(sb.toString(), null);
    }
:}

terminal String
    ADD,
    AND,
    ARRAY,
    ASSIGN,
    BEGIN,
    CASE,
    CHARACTER,
    COLONS,
    COMMA,
    CONST,
    DIV,
    DO,
    DOT,
    DOUBLE_DOT,
    ELSE,
    END,
    EQ,
    FOR,
    FUNCTION,
    GEQ,
    GT,
    IF,
    INTEGER,
    LEFT_BRACKET,
    LEFT_PARENTHESIS,
    LEQ,
    LT,
    MOD,
    MUL,
    NEQ,
    NOT,
    OF,
    OR,
    PROCEDURE,
    PROGRAM,
    REAL,
    RECORD,
    RIGHT_BRACKET,
    RIGHT_PARENTHESIS,
    SEMI_COLONS,
    SUB,
    THEN,
    TO,
    TYPE,
    VAR,
    WHILE
    ;

terminal String
    IDENTIFIER,
    NUMERIC_INTEGER_CONST,
    NUMERIC_REAL_CONST,
    STRING_CONST
    ;


non terminal PLSymbol
    alltypes,
    asig,
    blq,
    case,
    caselist,
    ctelist,
    cond,
    dcl,
    dcl_blq,
    dcllist,
    dcllist_blq,
    defcte,
    deffun,
    defproc,
    deftype,
    defvar,
    defvarlist,
    elsecond,
    exeblq,
    exp,
    explist,
    factor,
    floop,
    formal_param,
    formal_paramlist,
    id,
    initial,
    op,
    oparit,
    opcomp,
    oplog,
    prg,
    prog_call,
    sent,
    sentlist,
    simpvalue,
    subpparamlist,
    tbas,
    typelist,
    udtype,
    varlist,
    wloop
    ;

precedence left SEMI_COLONS;

precedence left ELSE;
precedence left OR;
precedence left AND;

precedence left LT;
precedence left LEQ;
precedence left GT;
precedence left GEQ;
precedence left EQ;
precedence left NEQ;
precedence left ADD, SUB;
precedence left MUL, DIV, MOD;

precedence left NOT;
precedence left LEFT_PARENTHESIS, RIGHT_PARENTHESIS;

start with initial;

initial ::=
    prg
        {: RESULT = SymbolFactory.result(errors); :};

prg ::=
    PROGRAM IDENTIFIER SEMI_COLONS blq DOT
    ;

blq ::=
    dcllist BEGIN sentlist END
    ;

dcllist ::=
      dcllist dcl
    | /* empty dcllist */
    ;

sentlist ::=
      sent
    | sentlist sent
    ;

dcl ::=
      defcte
    | defvar
    | defproc
    | deffun
    | deftype
    ;

defcte ::=
    CONST ctelist
    ;

ctelist ::=
      IDENTIFIER EQ simpvalue SEMI_COLONS
    | ctelist IDENTIFIER EQ simpvalue SEMI_COLONS
    ;

simpvalue ::=
      NUMERIC_INTEGER_CONST:value
        {: RESULT = SymbolFactory.simpvalue(value, valueleft, valueright); :}
    | NUMERIC_REAL_CONST:value
        {: RESULT = SymbolFactory.simpvalue(value, valueleft, valueright); :}
    | STRING_CONST:value
        {: RESULT = SymbolFactory.simpvalue(value, valueleft, valueright); :}
    ;

defvar ::=
    VAR defvarlist SEMI_COLONS
    ;

defvarlist ::=
      varlist COLONS alltypes
    | defvarlist SEMI_COLONS varlist COLONS alltypes
    ;

varlist ::=
      IDENTIFIER
    | IDENTIFIER COMMA varlist
    ;

defproc ::=
    PROCEDURE IDENTIFIER formal_paramlist SEMI_COLONS blq SEMI_COLONS
    ;

deffun ::=
    FUNCTION IDENTIFIER formal_paramlist COLONS alltypes SEMI_COLONS blq SEMI_COLONS
    ;

formal_paramlist ::=
      LEFT_PARENTHESIS formal_param RIGHT_PARENTHESIS
    | /* empty formal_paramlist */
    ;

formal_param ::=
      varlist COLONS alltypes
    | varlist COLONS alltypes SEMI_COLONS formal_param
    ;

tbas ::=
      INTEGER
    | REAL
    | CHARACTER
    ;

sent ::=
      asig SEMI_COLONS
    | asig:a
        {: error(SyntaxError.MISSING_SEMI_COLONS, a); :}
    | prog_call SEMI_COLONS
    | prog_call:pc
        {: error(SyntaxError.MISSING_SEMI_COLONS, pc); :}
    | exeblq
    | cond
    | wloop
    | floop
    | case
    ;

asig ::=
      id:id ASSIGN:assign exp:exp
        {: RESULT = SymbolFactory.asig(id, assign, exp); :}
    ;

id ::=
      IDENTIFIER:identifier
        {: RESULT = SymbolFactory.id(identifier, identifierleft, identifierright); :}
    | IDENTIFIER LEFT_BRACKET exp RIGHT_BRACKET
    | IDENTIFIER DOT IDENTIFIER
    ;

exp ::=
      exp op exp
    | factor:factor
        {: RESULT = SymbolFactory.exp(factor); :}
    ;

op ::=
      opcomp
    | oplog
    | oparit
    ;

opcomp ::=
      LT
    | GT
    | LEQ
    | GEQ
    | EQ
    | NEQ
    ;

oparit ::=
      ADD
    | SUB
    | MUL
    | DIV
    | MOD
    ;

oplog ::=
      OR
    | AND
    ;

factor ::=
      simpvalue:simpvalue
        {: RESULT = SymbolFactory.factor(simpvalue); :}
    | NOT factor
    | LEFT_PARENTHESIS exp RIGHT_PARENTHESIS
    | IDENTIFIER subpparamlist
    | IDENTIFIER LEFT_BRACKET exp RIGHT_BRACKET
    | IDENTIFIER DOT IDENTIFIER
    ;

subpparamlist ::=
      LEFT_PARENTHESIS explist RIGHT_PARENTHESIS
    | /* empty subpparamlist */
    ;

explist ::=
      exp
    | exp COMMA explist
    ;

prog_call ::=
    IDENTIFIER subpparamlist
    ;

exeblq ::=
    dcllist_blq BEGIN sentlist END
    ;

dcllist_blq ::=
      dcllist_blq SEMI_COLONS dcl_blq
    | /* empty dcllist_blq */
    ;

dcl_blq ::=
      defcte
    | deftype
    | defvar
    ;

deftype ::=
    TYPE typelist
    ;

typelist ::=
      IDENTIFIER EQ udtype SEMI_COLONS
    | IDENTIFIER EQ udtype SEMI_COLONS typelist
    ;

udtype ::=
      ARRAY LEFT_BRACKET simpvalue DOUBLE_DOT simpvalue RIGHT_BRACKET OF alltypes
    | RECORD defvarlist END
    ;

alltypes ::=
      tbas
    | IDENTIFIER
    ;

cond ::=
    IF exp THEN sent elsecond
    ;

elsecond ::=
      ELSE sent
    | /* empty elsecond */
    ;

wloop ::=
    WHILE exp DO sent
    ;

floop ::=
    FOR IDENTIFIER ASSIGN exp TO exp DO sent
    ;

case ::=
    CASE exp OF caselist END
    ;

caselist ::=
      exp COLONS sent SEMI_COLONS
    | exp COLONS sent SEMI_COLONS caselist
    ;
